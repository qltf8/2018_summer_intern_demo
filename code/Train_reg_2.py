# 1. RNN based two GRUs. The sequence of one GRU is daily price and volume info and learn in vertical direction, while the other is generated by spliting and concatinate
#    price and volume vertically and Rnn will scan the matrix in horizon direction.
# 2. predict return rate
# 3. intended to be deployed in long term context




import numpy as np
import pandas as pd
import json
import sys
from datetime import datetime,timedelta
import os
import re
import torch
from Rnn import Reg_Rnn_160_2
import traceback

class Train():
    def __init__(self, model_start_day, major_stock_files, minor_stock_files, model_dir_name ,num_day_advance = 5, delta_t = 25, max_training_times = 60, is_random = False):
        '''
        model_start_day : the day when the model would be deployed.
        major_stock_files: the list of stocks filepath  used to train model (should be same as the stocks need to be predicted latter)
        minor_stock_files: the list of stocks filepath used to train model (these stocks may not be used to make prediction, be considered as supplement to training data)
        num_day_advance: predict how the stock will change in the following $num_day_advance$ business days.
        delta_t: the number of day you want to use to predict the stock market
        '''
        print('----------------------------------------------',model_start_day,'---------------------------------------------')
        
        self.major_stock_files,unvalid_list = self.unvalid_file_detection(major_stock_files)
        print('invalid major_stock_files (empty or non-exist): ', unvalid_list)
        self.minor_stock_files, unvalid_list = self.unvalid_file_detection(minor_stock_files)
        print('invalid minor_stock_files (empty or non-exist): ', unvalid_list)
        
        sys.stdout.flush()
        
        self.model_start_day = model_start_day
        self.num_day_advance = num_day_advance
        self.max_training_times = max_training_times
        self.delta_t = delta_t
        self.is_random = is_random
        self.iteration_time = None
        self.model_dir_name = model_dir_name
        self.all_company_stock_tensor = None
        
        
            
    def unvalid_file_detection(self,file_lists):
        valid_list = []
        unvalid_list = []
        for file in file_lists:
            if (os.path.isfile(file)) and (os.stat(file).st_size > 0):
                valid_list.append(file)
            else:
                unvalid_list.append(file)
        return valid_list,unvalid_list
    
    
    
    def generate_training_matrix(self, total_stock_in_tensor = 500, max_threshold = 1900, min_threshold = 500, min_num_stocks = 10):
        '''
        this function generate training data
        total_stock_in_tensor: the maximum number of stocks used to train the model
        max_threshold : the maximum number of available days for any stock to train the model
        min_threshold : the minimum number of available days for any stock to train the model
        min_num_stocks: the requirement of the minimum number of valid stocks to train the model. If the number of stocks satifying
        this requirement is less that min_num_stocks, the program will be terminated.
        '''
        print('Preparing training data')
        sys.stdout.flush()
        
        candidate_stock_list = []
        final_stock_list = []
        all_stock_tensor = None


        for stock_file in self.major_stock_files:
            stock = pd.read_csv(stock_file,header=None,index_col=[0])
            stock = stock.loc[:self.model_start_day]
            stock = stock.iloc[:-1,:]
            if stock.shape[0] >= max_threshold:
                final_stock_list.append((stock_file,stock.shape[0]))
            elif stock.shape[0] >= min_threshold:
                candidate_stock_list.append((stock_file,stock.shape[0]))       

        for stock_file in self.minor_stock_files:
            stock = pd.read_csv(stock_file,header=None,index_col=[0])
            stock = stock.loc[:self.model_start_day]
            stock = stock.iloc[:-1,:]
            if stock.shape[0] >= min_threshold:
                candidate_stock_list.append((stock_file,stock.shape[0]))

        if len(final_stock_list) + len(candidate_stock_list)  <= total_stock_in_tensor:
            final_stock_list.extend(candidate_stock_list)
        else:
            for stock_and_len in sorted(candidate_stock_list,key=lambda x : x[1], reverse=True):
                if len(final_stock_list) < total_stock_in_tensor:
                    final_stock_list.append(stock_and_len)
                else:
                    break
        assert len(final_stock_list) >= min_num_stocks, 'Error: the number of valid stock (more than 500 available day)\
        is less that the requirement(10)'
        
        
    
        num_of_day = sorted(final_stock_list,key=lambda x : x[1], reverse=True)[-1][-1]
        
        if num_of_day> max_threshold:
            num_of_day = max_threshold
        
        for stock_file,length in final_stock_list:
            stock = pd.read_csv(stock_file,header=None,index_col=[0])
            stock = stock.loc[:self.model_start_day]
            stock = stock.iloc[:-1,:].copy()
            stock.iloc[:,-1] = np.log(stock.iloc[:,-1]).diff(self.num_day_advance).shift(-self.num_day_advance)
            stock = stock.as_matrix()[np.newaxis,-num_of_day:,:]
            if all_stock_tensor is None:
                all_stock_tensor = stock.copy()
            else:
                all_stock_tensor = np.concatenate([all_stock_tensor,stock])
        print(self.model_start_day, ' get matrix shape',all_stock_tensor[:,:-5-self.num_day_advance,:].shape, 'the number of stock in major list:',
             len(set(self.major_stock_files).intersection(set([i for i,j in final_stock_list]))), 'the number of stock in minor list:',
             len(set(self.minor_stock_files).intersection(set([i for i,j in final_stock_list]))))
        return torch.from_numpy(all_stock_tensor[:,:-5-self.num_day_advance,:]).float()
    
    
    
    def train_160(self,epoch,model,optimizer):
        #Not shown
        pass
    
    
    def get_day_company_index(self,input_index):
        '''
        Generate training index
        '''
        input_index = input_index.copy()
        num_company = self.all_company_stock_tensor.shape[0]
        if self.is_random:
            np.random.shuffle(input_index)
        output = []
        if num_company >= 400:
            batch_size = 64
        elif num_company >= 200:
            batch_size = 32
        elif num_company >= 64:
            batch_size = 16
        else:
            batch_size = 4
        for start in input_index:
            selected_company = np.random.choice(num_company,batch_size,replace=False)
            selected_day = np.arange(start,start+self.delta_t)
            output.append((selected_company,selected_day))
        return output
    
        
       
    
    def desired_model_time(self):
        if self.is_random:
            self.iteration_time = 60
        else:
            if self.all_company_stock_tensor.shape[1] <= 1200:
                self.iteration_time =  60
            elif self.all_company_stock_tensor.shape[1] <= 1400:
                self.iteration_time =  60
            elif self.all_company_stock_tensor.shape[1] <= 1600:
                self.iteration_time =  60
            elif self.all_company_stock_tensor.shape[1] <= 1700:
                self.iteration_time =  60
            else:
                self.iteration_time =  20
            
            
    # the threshold for the reduction of the value of loss function            
    def desired_reduce_time(self):
        if self.all_company_stock_tensor.shape[1] <= 1700:
            return  0.045
        else:
            return  0.042
    
    
    def train_model(self):
        all_company_stock_tensor = self.generate_training_matrix()
        self.all_company_stock_tensor = all_company_stock_tensor.cuda()
        num_of_training_times = 0
        self.desired_model_time()
        print('start training model Reg_Rnn_160_2, model_start_day : ',self.model_start_day, ' random status: ',self.is_random, ' \n recommended training times: ',self.iteration_time)
        while True:
            num_of_training_times += 1
            print(self.model_start_day, 'training times : ',num_of_training_times)
            model_1 = Reg_Rnn_160_2(delta_t=self.delta_t, hidden_size = 160)
            
            model_1.num_day_advance = self.num_day_advance
            model_1.major_stock_files = self.major_stock_files
            model_1.minor_stock_files = self.minor_stock_files
            
            model_1.init_GRU_weight()
            model_1 = model_1.cuda()
            optimizer = torch.optim.Adagrad([p for p in model_1.parameters() if p.requires_grad],
                                           lr = 0.005, weight_decay=0.0)
            previous_loss = 0
            success = True
            for i in range(1,self.max_training_times+1):
                
                loss = self.train_160(epoch = i,  model = model_1, optimizer = optimizer)
                if i == 2:
                    first_loss = loss
                if (i >= 2) and (i < 6) and (loss > previous_loss):
                    success = False 
                    print('Did not continus decreasing, retrain the model')
                    break
                if (i == 11) and (first_loss*self.desired_reduce_time() > (first_loss - loss)):
                    success = False
                    print('threshold: ', self.desired_reduce_time() ,' Loss value was not reduced enough, retrain the model, actural value:', (first_loss - loss)/first_loss)
                    break
                if (i == 11):
                    print('Success, actural value: ', (first_loss - loss)/first_loss)
                if i == self.iteration_time:
                    torch.save(model_1,self.model_dir_name + 'Reg_Rnn_160_2_0_'+self.model_start_day)
                if (i == 1) or (i % 5 == 0):
                    torch.save(model_1,self.model_dir_name + 'Reg_Rnn_160_2_'+str(i)+'_'+self.model_start_day)
                previous_loss = loss
                sys.stdout.flush()
            if success:
                break

        
    
    
    
 
 
 
 
def process_dir(dir_name):
    dir_name = dir_name.replace('\\','/')
    if dir_name[-1] != '/':
        dir_name = dir_name + '/'
    return dir_name



if __name__ == '__main__':
    
    #print(sys.argv)
    if len(sys.argv) < 2:
        major_stock_files = [file for file in os.listdir('../500_3mins_wv_positive/') if re.findall("^[a-zA-Z0-9]+.+\.csv$",file)]
        major_stock_files = ['../500_3mins_wv_positive/'+file for file in major_stock_files]
        minor_stock_files = [file for file in os.listdir('../300_3mins_wv_positive/') if re.findall("^[a-zA-Z0-9]+.+\.csv$",file)]
        minor_stock_files = ['../300_3mins_wv_positive/'+file for file in minor_stock_files]
        candidate_stock_list = major_stock_files
        
        
        paras_dict = {'model_start_day' : '2014-01-01',
         'major_stock_files' : major_stock_files, 
         'minor_stock_files' : minor_stock_files, 
         'model_dir_name' : '../model/',
         'num_day_advance' : 5, 
         'delta_t' : 25, 
         'max_training_times' : 25} 
    else:
        try:
            paras = sys.argv[1]
            paras = paras.replace('\\','')
            paras_dict = json.loads(paras)
        except Exception as e:
            print('Error: ', e)
    try:
        model_start_day = paras_dict['model_start_day']
        major_stock_files = paras_dict['major_stock_files']
        minor_stock_files = paras_dict['minor_stock_files']
        is_random = paras_dict.get('is_random', 0)
        if is_random == 0:
            is_random = False
        elif is_random == 1:
            is_random = True
        else:
            assert False, 'Error: ' + str('is_random must be 0 or 1, the value passed is : ' + str(is_random))
        model_dir_name = process_dir(paras_dict['model_dir_name'])
        num_day_advance = paras_dict.get('num_day_advance',5)
        delta_t = paras_dict.get('delta_t',25)
        max_training_times = paras_dict.get('max_training_times',60)
    except Exception as e:
        assert False, 'Error: ' + str(e)


    try:
        print('Start reg_rnn_2 training.\n The number of major stock files: ',len(major_stock_files),
              '\n The number of minor stock files: ',len(minor_stock_files),
              '\n model_start_day: ',model_start_day)
        
        train = Train(model_start_day = model_start_day, major_stock_files = major_stock_files,
                      minor_stock_files = minor_stock_files, model_dir_name = model_dir_name, is_random = is_random,
                      num_day_advance=num_day_advance, delta_t = delta_t, max_training_times = max_training_times)

        train.train_model()
        print('Finish training successfully')
    except Exception as e:
        print('Error: ', e)
        print(traceback.format_exc())
    
